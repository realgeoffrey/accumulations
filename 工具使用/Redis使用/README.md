### [Redis](https://github.com/antirez/redis)使用
1. 启动客户端：[`redis-cli`](https://redis.io/commands)

    1. `set 「key」 「value」 「EX或PX」 「秒或毫秒」 「NX或XX」`

        1. `NX`：Only set the key if it does not already exist.
        2. `XX`：Only set the key if it already exist.
    2. `get 「key」`
    3. `del 「key1」 「key2」`
    4. `keys *`
2. 特性

    1. 存储在内存磁盘上。

        速度快，但内存不是持久存储、容易丢失（重启或断电）。
    2. 键-值方式存储和使用。
3. 案例

    1. 获取「其他资源」（如：.json或其他接口）并处理后返回信息的API

        1. 方案一：~~每次请求都抓取一次「其他资源」~~
        2. 方案二：~~使用Redis设置过期时间~~
        3. 方案三：Redis相关存储：`{ 内容, 过期时间 }`、`锁`（并发控制）

            1. Redis设置长时间存在；
            2. 任何请求都直接返回Redis保存的「内容」（若首次请求没有存入Redis，则获取「其他资源」后存入Redis）；
            3. 同时异步进行：若判定过期且「锁」关闭，则开启「锁」，异步抓取「其他资源」后更新「内容」、「过期时间」并关闭「锁」。

- 问题

    1. 缓存雪崩

        是指在短时间内，有大量缓存同时过期，导致大量的请求直接查询数据库，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机的情况叫做缓存雪崩。

        - 解决方案

            1. 加锁排队

                加锁排队可以起到缓冲的作用，防止大量的请求同时操作数据库，但它的缺点是增加了系统的响应时间，降低了系统的吞吐量，牺牲了一部分用户体验。
            2. 随机化过期时间

                为了避免缓存同时过期，可在设置缓存时添加随机时间，这样就可以极大的避免大量的缓存同时失效。
            3. 设置二级缓存

                二级缓存指的是除了 Redis 本身的缓存，再设置一层缓存，当 Redis 失效之后，先去查询二级缓存 而非查询数据库。
            4. 设置热点数据永不过期
    2. 缓存穿透

        缓存穿透是指查询数据库和缓存都无数据，因为数据库查询无数据，出于容错考虑，不会将结果保存到缓存中，因此每次请求都会去查询数据库，这种情况就叫做缓存穿透。

        - 解决方案

            1. 使用过滤器

                我们可以使用过滤器来减少对数据库的请求，例如使用布隆过滤器（它的原理是将数据库的数据哈希到 bitmap 中，每次查询之前，先使用布隆过滤器过滤掉一定不存在的无效请求，从而避免了无效请求给数据库带来的查询压力）。
            2. 缓存空结果

                另一种方式是我们可以把每次从数据库查询的数据都保存到缓存中，为了提高前台用户的使用体验 (解决长时间内查询不到任何信息的情况)，我们可以将空结果的缓存时间设置得短一些，例如 3~5 分钟。
            3. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
    3. 缓存击穿

        缓存击穿指的是某个热点缓存，在某一时刻恰好失效了，然后此时刚好有大量的并发请求，此时这些请求将会给数据库造成巨大的压力，这种情况就叫做缓存击穿。

        - 解决方案

            1. 加锁排队

                此处理方式和缓存雪崩加锁排队的方法类似，都是在查询数据库时加锁排队，缓冲操作请求以此来减少服务器的运行压力。
            2. 设置热点数据永不过期

                对于某些热点缓存，我们可以设置永不过期，这样就能保证缓存的稳定性，但需要注意在数据更改之后，要及时更新此热点缓存，不然就会造成查询结果的误差。
            3. 接口限流与熔断，降级

                重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。
    4. 缓存污染（或满了）

        缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。

        缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。
- 优化

    1. 缓存预热

        缓存预热指的是在系统启动的时候，先把查询结果预存到缓存中，以便用户后面查询时可以直接从缓存中读取，以节约用户的等待时间。

        - 方案

            1. 把需要缓存的方法写在系统初始化的方法中，这样系统在启动的时候就会自动的加载数据并缓存数据；
            2. 把需要缓存的方法挂载到某个页面或后端接口上，手动触发缓存预热；
            3. 设置定时任务，定时自动进行缓存预热。
