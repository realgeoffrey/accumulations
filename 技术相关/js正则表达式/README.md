# 正则表达式（javascript）

## 创建 RegExp 对象
- 创建方式

    如果要匹配字符“\”

    - 字面量

        ```javascript
        /\\/igm;  //需要对"\"进行转义
        ```
    - 构造函数

        ```javascript
        new RegExp('\\\\', 'i', 'g', 'm');   //要对两个"\"都进行转义
        ```

    当表达式被求值时，字面量形式提供正则表达式的编译（compilation）状态。因此正则表达式的为常量。例如当你在循环中使用字面量构造一个正则表达式时，正则表达式不会在每一次迭代中都被重新编译（recompiled）。

    而正则表达式对象的构造函数，如 new RegExp("ab+c") 提供了正则表达式运行时编译（runtime compilation）。如果你知道正则表达式模式将会改变，或者你事先不知道什么模式，而是从另一个来源获取，如用户输入，这些情况都可以使用构造函数。
    当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。

- 修饰符

    - `i`：
        ingore case，忽略大小写，默认大小写敏感

    - `g`：
        global，全文搜索，默认搜索到第一个结果接停止

    - `m`：
        multiple lines，多行搜索，默认单行搜索
 

## 特殊字符
- 需要转义的特殊字符

    `() [] {}  \ / ^ $ |  ? * + .`

    因为有特殊含义，所以在使用以上元字符的字面值时必须对其进行`\`转义。

    >可以对任何字符进行`\`转义。

- 元字符

    - 字符类别

        | 字符 | 表示的意义 | 字符 | 表示的意义 |
        | :---: | :--- | :---: | :--- |
        | `.` | 匹配任意单个字符，但是**换行符**除外（包括：\n \r \u2028 或 \u2029）。需要注意的是，m 多行（multiline）标志不会改变点号的匹配表现。 |  |  |
        | `\d` | 匹配基本拉丁字母表（basic Latin alphabet）中的一个数字字符。等价于`[0-9]`。 | `\D` | 匹配任意一个不是基本拉丁字母表中数字的字符。等价于`[^0-9]`。 |
        | `\w` | 匹配任意来自基本拉丁字母表中的字母、数字和下划线。等价于`[A-Za-z0-9_]`。 | `\W` | 匹配任意不是基本拉丁字母表中单词（字母、数字和下划线）字符的字符。等价于`[^A-Za-z0-9_]`。 |
        | `\s` | 匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。等价于`[ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​\u2001\u2002​\u2003\u2004​ \u2005\u2006​\u2007\u2008​\u2009\u200a​\u2028\u2029​​\u202f\u205f​ \u3000]`。 | `\S` | 匹配一个非空白符。等价于`[^ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​\u2001\u2002​\u2003\u2004​ \u2005\u2006​\u2007\u2008​\u2009\u200a​\u2028\u2029​\u202f\u205f​\u3000]`。 |
        | `\t` | 匹配一个水平制表符（tab）。 |  |  |
        | `\r` | 匹配一个回车符（carriage return）。 |  |  |
        | `\n` | 匹配一个换行符（linefeed）。 |  |  |
        | `\v` | 匹配一个垂直制表符（vertical tab）。 |  |  |
        | `\f` | 匹配一个换页符（form-feed）。 |  |  |
        | `[\b]` | 匹配一个退格符（backspace）（不要与`\b`混淆）。 |  |  |
        | `\0` | 匹配一个 NUL 字符。不要在此后面跟小数点。 |  |  |
        | `\cX` | X 是 A - Z 的一个字母。匹配字符串中的一个控制字符。例如，`/\cM/`匹配字符串中的 control-M。 |  |  |
        | `\xhh` | 匹配编码为 hh （两个十六进制数字）的字符。 |  |  |
        | `\uhhhh` | 匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。 |  |  |
        | `\` | 对于那些通常被认为字面意义的字符来说，表示下一个字符具有特殊用处，并且不会被按照字面意义解释。 |  |  |

    - 字符集合

        | 字符 | 表示的意义 | 字符 | 表示的意义 |
        | :---: | :--- | :---: | :--- |
        | `[xyz]` | 匹配集合中的任意一个字符。也以使用连字符`-`指定一个范围。 | `[^xyz]` | 匹配任意不在括号内的字符。也可通过使用连字符`-`指定一个范围内的字符。 |

    - 边界

        | 字符 | 表示的意义 | 字符 | 表示的意义 |
        | :---: | :--- | :---: | :--- |
        | `^` | 匹配输入`/`字符串的开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。 |  |  |
        | `$` | 匹配输入`/`字符串的结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。 |  |  |
        | `\b` | 匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。 （不要和`[\b]`混淆）。 | `\B` | 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。 |

    - 分组

        | 字符 | 表示的意义 | 字符 | 表示的意义 |
        | :---: | :--- | :---: | :--- |
        | `(x)` | 匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。 | `(?:x)` | 匹配 x 不会捕获匹配项。这被称为非捕获括号（non-capturing parentheses）。 |
        | `\n` | n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个捕获匹配项（从左开始数）中匹配的子字符串。 |  |  |

        >括号分组可以嵌套，外部的分组比内部分组的编号靠前。
        >
        >`RegExp.$1`~`RegExp.$9`值为String类型，返回上一次正则表达式匹配中第n个分组所匹配的文本。
    - 数量词

        | 字符 | 表示的意义 | 字符 | 表示的意义 |
        | :---: | :--- | :---: | :--- |
        | `x?` | 匹配前面的模式 x 0 或 1 次。 |  |  |
        | `x*` | 匹配前面的模式 x 0 或多次。 |  |  |
        | `x+` | 匹配前面的模式 x 1 或多次。等价于`{1,}`。 |  |  |
        | `x{n}` | n 是一个正整数。前面的模式 x 连续出现 n 次时匹配。 |  |  |
        | `x{n,}` | n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。 |  |  |
        | `x{,m}` | m 是一个正整数。前面的模式 x 连续出现至多 m 次时匹配。 |  |  |
        | `x{n,m}` | n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。 |  |  |
        | `x*?`或`x+?`或`x{n,}?` | 惰性模式，只进行最小限度的匹配（默认贪婪模式）。 |  |  |
        | `x|y` | 匹配 x 或 y。 |  |  |
        | `x(?=y)` | 只有当 x 后面紧跟着 y 时，才匹配 x。 | `x(?!y)` | 只有当 x 后面不是紧跟着 y 时，才匹配 x |

        >贪婪模式：趋向于最大长度匹配。

## 正则方法

- RegExp对象的方法

    - `regexObj.test(str)`

        判断正则表达式与指定的字符串是否匹配。返回`true`或`false`。
    - `regexObj.exec(str)`

        指定的一段字符串执行搜索匹配操作。返回一个数组或者`null`。

        如果成功匹配，exec 方法返回一个数组，并且更新正则表达式对象的属性。返回的数组包括匹配的字符串作为第一个元素，紧接着一个元素对应一个成功匹配被捕获的字符串的捕获括号（capturing parenthesis）。

        >例：
        >
        >```javasscript
        >var regexObj = /quick\s(brown).+?(jumps)/ig;
        >var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');
        >```
        >
        >产生的结果：
        >
        >| 对象 | 属性/索引 | 描述 | 例子中的值 |
        >| :---: | :--- | :---: | :--- |
        >| `regexObj` | `[0]` | 匹配的全部字符串 | `Quick Brown Fox Jumps` |
        >|  | `[1], ...[n ]` | 括号中的分组捕获 | `[1] = Brown` `[2] = Jumps` |
        >|  | `index` | 匹配到的字符位于原始字符串的基于0的索引值 | 4 |
        >|  | `input` | 原始字符串 | `The Quick Brown Fox Jumps Over The Lazy Dog` |
        >
        >| 对象 | 属性/索引 | 描述 | 例子中的值 |
        >| `result` | `lastIndex` | 下一次匹配开始的位置 | 25 |
        >|  | `ignoreCase` | 是否使用了'i'标记使正则匹配忽略大小写 | `true` |
        >|  | `global` | 是否使用了'g'标记来进行全局的匹配 | `true` |
        >|  | `multiline` | 是否使用了'm'标记使正则工作在多行模式（也就是，^ 和 $ 可以匹配字符串中每一行的开始和结束（行是由 \n 或 \r 分割的），而不只是整个输入字符串的最开始和最末尾处。） | `false` |
        >|  | `source` | 正则模式的字符串 | `quick\s(brown).+?(jumps)` |

    #### exec()
    在字符串中匹配，返回包含第匹配项信息的数组，没有则返回null。

    包含两个属性：
    - index ：匹配项在字符串中的位置
    - input ：应用正则的字符串

    全局模式下，每次调用exec()会在字符串中继续查找新匹配项；否则会重新从头匹配。

    ```
    var str = "Chrome/48.0.2564.109";
    var reg = /(\d+)\./g;  //全局模式

    var a = reg.exec(str); //["48.", "48", index: 7, input: "Chrome/48.0.2564.109"]
    var b = reg.exec(str); //["0.", "0", index: 10, input: "Chrome/48.0.2564.109"]
    var c = reg.exec(str); //["2564.", "2564", index: 12, input: "Chrome/48.0.2564.109"]

    a.index; //7
    b.input; //Chrome/48.0.2564.109
    ```

    ## 支持正则表达式的 String 对象的方法
    #### search() 

    返回匹配到的字符串所在的位置， 没有则返回-1

    ```javascript
    var str = "Chrome/48.0.2564.109";
    var reg = /\/(\d+)\./i;

    str.search(reg); //6
    ```

    #### match()
    查找符合正则的字符串，以数组的形式返回（ 注意全局，否则只返回第一个 ） ,  没有就返回null

    ```javascript
    var str = "Chrome/48.0.2564.109";

    //非全局模式
    var reg1 = /(\d+)\./;  
    str.match(reg1);  //["48.", "48", index: 7, input: "Chrome/48.0.2564.109"]

    //全局模式
    var reg2 = /(\d+)\./g;
    str.match(reg2);  //["48.", "0.", "2564."]
    ```

    #### split()
    将字符串转换成数组，以传入参数为间隔

    ```javascript
    var str = "Chrome/48.0.2564.109";

    str.split(/[\/\.]/); //["Chrome", "48", "0", "2564", "109"]
    ```

    #### replace ( )
    查找替换字符串（注意全局，否则只替换第一个）

    - 参数1 ：`字符串` 或者 `正则`，表示查找的字符串。（如果第一个参数是字符串，那么只会替换第一个子字符串。要替换所有子字符串就必须传正则表达式，并且要制定全局g标志 ）

    - 参数2： `字符串` 或者 `函数` ，表示替换的字符串。

    ```javascript
     //当正则里没有分组时：
     var   str =  '中华人民共和国' ;
     var   reg = /人/g;
     var   nStr = str.replace(reg, function (){
          console.log(arguments[0] +  ' '   + arguments[1] +  ' '   + arguments[2]);
          /* 第一个参数表示匹配的字符串，即'人'；
           * 第二个参数表示匹配的字符串出现的位置，即2；
           * 第三个参数表示目标字符串，即'中华人民共和国'；
           */
     });

     //当正则里有一个或多个分组时：
     var   str =  '中华人民 共 和国' ;
     var   reg = /(人)民(共)/g;
     var   nStr = str.replace(reg, function (){
          console.log(arguments[0] +  ' '   + arguments[1] +  ' '   + arguments[2]);
          /* 第一个参数表示匹配的字符串，即'人民共'；
           * 第二个参数表示第一个分组匹配的字符串，即（人）；
           * 第三个参数表示第二个分组匹配的字符串，即（共）；
           * 以此类推……
           * 倒数第二个参数表示匹配的字符串出现的位置，即2；
           * 最后一个参数表示目标字符串，即'中华人民共和国'；
           */
     });
    ```