# 正则表达式（javascript）

## 创建 RegExp 对象
- 创建方式

    如果要匹配字符“\”

    - 字面量

        ```javascript
        /\\/igm;  //需要对"\"进行转义
        ```
    - 构造函数

        ```javascript
        new RegExp('\\\\', 'i', 'g', 'm');   //要对两个"\"都进行转义
        ```

    当表达式被求值时，字面量形式提供正则表达式的编译（compilation）状态。因此正则表达式的为常量。例如当你在循环中使用字面量构造一个正则表达式时，正则表达式不会在每一次迭代中都被重新编译（recompiled）。

    而正则表达式对象的构造函数，如 new RegExp("ab+c") 提供了正则表达式运行时编译（runtime compilation）。如果你知道正则表达式模式将会改变，或者你事先不知道什么模式，而是从另一个来源获取，如用户输入，这些情况都可以使用构造函数。
    当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。

- 修饰符

    - `i`：
        ingore case，忽略大小写，默认大小写敏感

    - `g`：
        global，全文搜索，默认搜索到第一个结果接停止

    - `m`：
        multiple lines，多行搜索，默认单行搜索
 

## 特殊字符
- 需要转义的特殊字符

    `() [] {}  \ / ^ $ |  ? * + .`

    因为有特殊含义，所以在使用以上元字符的字面值时必须对其进行`\`转义。

    > 可以对任何字符进行`\`转义。

- 元字符

    **预定义特殊字符**

    |字符|表示的意义|
    |---|---|||
    |\r|回车符|
    |\n|换行符|

    **预定义类**

    |字符|表示的意义|字符|表示的意义|
    |---|---|---|---|
    |.|换行和回车以外的任何单个字符|||
    |\w|代表任意字母和数字和\_ |\W|表示非字母和数字和\_ |
    |\d|代表任意数字|\D| 表示非数字|
    |\s|代表空白符|\S| 表示非空格|

    **边界**

    |字符|表示的意义|
    |---|---|
    |^|行首匹配|
    |$|尾匹配|
    |\b|表示单词边界，代表着单词的开头或者结尾|
    |\B|表示非单词边界|

    **前瞻**

    |字符|表示的意义|
    |---|---|||
    |a(?=b)|匹配任何其后紧接指定字符串 b 的 a。|
    |b(?!a)|匹配任何其后没有紧接指定字符串 b 的 a。|
    ```javascript
    var str = 'Chrome/48.0.2564.109';

    var reg1 = /(\d+\.)(?=0)/g;  //匹配后面有 0 的字符串
    var reg2 = /(\d+\.)(?!0)/g;  //匹配后面没有 0 的字符串

    str.match(reg1); //["48."]  
    str.match(reg2); //["0.", "2564."]
    ```

    **或**

    可以用竖线（|）字符表示或者的关系。
    ```
    var str = ' abc ';
    str.replace(/^(\s+)|(\s+)$/g,''); //去除首尾的空格
    ```


    ## 量词

    |字符|表示的意义|
    |---|---|||
    |a?|0个或1个（最多一次）|
    |a+|1个或多个（至少一次）|
    |a\*|0个或多个（任意次）|
    |a{n}|正好n次|
    |a{n, m}|最少n次，最多m次|
    |a{n, }|最少n次，最多不限|
    |a{ , m}|最少不限，最多m次|

    惰性模式： 只进行最小限度的匹配。
    贪婪模式： 默认，趋向于最大长度匹配。
     
    在 `量词` 后面直接加上一个问号`？`，就是惰性模式。
     
    ```
     a*       –>    a*? 
     a+       –>    a+?
     a{n,}    –>    a{n,}?
    ```

    ## 范围类

    可以使用元字符`[]`来定义一个字符集合（字符类）来进行匹配

    |字符|表示的意义|
    |---|---|
    | [abc]| 查找方括号之间的任何一个字符。|
    |[^abc]| 查找任何不在方括号之间的字符。|
    |[0-9]|查找任何从 0 至 9 的数字。|
    |[a-z]|查找任何从小写 a 到小写 z 的字符。|
    |[A-Z]|查找任何从大写 A 到大写 Z 的字符。|
    |[\u4e00-\u9fa5]|匹配中文|

    ##  分组(子表达式)

    有时候我们希望使用量词的时候匹配多个字符，而不是像 [] 里面只能匹配一个，可以使用 `()`把字符作为一个整体进行匹配。

    正则里的分组会被捕获，分组按数字编号划分。分组可以嵌套，外部的分组比内部分组的编号靠前。

    `RegExp.$1...$9`属性的值为String类型，返回上一次正则表达式匹配中，第n个分组所匹配的文本。

    ```javascript
    var str = 'Chrome/48.0.2564.109';

    /((\d+)\.)+/i.exec(str);
    /*
     * ["48.0.2564.", "2564.", "2564", index: 7, input: "Chrome/48.0.2564.109"]
     * 正则里有两个分组，两个分组分别捕获了 "2564." 和 "2564",
     */
    RegExp.$1;  //2564.
    RegExp.$2;  //2564
    ```

    **不捕获**
    有时候我们不希望捕获某些分组，只需要在分组内加上 `?:` 就可以了。
    ```javascript
    var str = 'Chrome/48.0.2564.109';

    /((?:\d+)\.)+/i.exec(str);
    /*
     * ["48.0.2564.", "2564.", index: 7, input: "Chrome/48.0.2564.109"]
     * 正则里有两个分组，但是第二个分组定义了 ?: 不捕获
     */
     RegExp.$1;  //2564.
     RegExp.$2;  //空
    ```

    **捕获的反向应用**

    \n 表示第n个分组的匹配项,这个匹配项需要在执行的时候才定
    ```javascript
    var str = '<strong>this is html</strong>';
    var reg = /<(\w+)>.*<\/\1>/g;

    str.match(reg); //["<strong>this is html</strong>"]
    ```

    ## 正则的方法：
    #### test()
    在字符串中匹配，如果有就返回true，没有则返回false。

    #### exec()
    在字符串中匹配，返回包含第匹配项信息的数组，没有则返回null。

    包含两个属性：
    - index ：匹配项在字符串中的位置
    - input ：应用正则的字符串

    全局模式下，每次调用exec()会在字符串中继续查找新匹配项；否则会重新从头匹配。

    ```
    var str = "Chrome/48.0.2564.109";
    var reg = /(\d+)\./g;  //全局模式

    var a = reg.exec(str); //["48.", "48", index: 7, input: "Chrome/48.0.2564.109"]
    var b = reg.exec(str); //["0.", "0", index: 10, input: "Chrome/48.0.2564.109"]
    var c = reg.exec(str); //["2564.", "2564", index: 12, input: "Chrome/48.0.2564.109"]

    a.index; //7
    b.input; //Chrome/48.0.2564.109
    ```

    ## 支持正则表达式的 String 对象的方法
    #### search() 

    返回匹配到的字符串所在的位置， 没有则返回-1

    ```javascript
    var str = "Chrome/48.0.2564.109";
    var reg = /\/(\d+)\./i;

    str.search(reg); //6
    ```

    #### match()
    查找符合正则的字符串，以数组的形式返回（ 注意全局，否则只返回第一个 ） ,  没有就返回null

    ```javascript
    var str = "Chrome/48.0.2564.109";

    //非全局模式
    var reg1 = /(\d+)\./;  
    str.match(reg1);  //["48.", "48", index: 7, input: "Chrome/48.0.2564.109"]

    //全局模式
    var reg2 = /(\d+)\./g;
    str.match(reg2);  //["48.", "0.", "2564."]
    ```

    #### split()
    将字符串转换成数组，以传入参数为间隔

    ```javascript
    var str = "Chrome/48.0.2564.109";

    str.split(/[\/\.]/); //["Chrome", "48", "0", "2564", "109"]
    ```

    #### replace ( )
    查找替换字符串（注意全局，否则只替换第一个）

    - 参数1 ：`字符串` 或者 `正则`，表示查找的字符串。（如果第一个参数是字符串，那么只会替换第一个子字符串。要替换所有子字符串就必须传正则表达式，并且要制定全局g标志 ）

    - 参数2： `字符串` 或者 `函数` ，表示替换的字符串。

    ```javascript
     //当正则里没有分组时：
     var   str =  '中华人民共和国' ;
     var   reg = /人/g;
     var   nStr = str.replace(reg, function (){
          console.log(arguments[0] +  ' '   + arguments[1] +  ' '   + arguments[2]);
          /* 第一个参数表示匹配的字符串，即'人'；
           * 第二个参数表示匹配的字符串出现的位置，即2；
           * 第三个参数表示目标字符串，即'中华人民共和国'；
           */
     });

     //当正则里有一个或多个分组时：
     var   str =  '中华人民 共 和国' ;
     var   reg = /(人)民(共)/g;
     var   nStr = str.replace(reg, function (){
          console.log(arguments[0] +  ' '   + arguments[1] +  ' '   + arguments[2]);
          /* 第一个参数表示匹配的字符串，即'人民共'；
           * 第二个参数表示第一个分组匹配的字符串，即（人）；
           * 第三个参数表示第二个分组匹配的字符串，即（共）；
           * 以此类推……
           * 倒数第二个参数表示匹配的字符串出现的位置，即2；
           * 最后一个参数表示目标字符串，即'中华人民共和国'；
           */
     });
    ```